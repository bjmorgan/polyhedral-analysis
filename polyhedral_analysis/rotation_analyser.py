from pymatgen.analysis.chemenv.coordination_environments.coordination_geometry_finder import symmetry_measure
from itertools import permutations
import math
import numpy as np

class RotationAnalyser(object):
    
    def __init__(self, reference_points):
        self.reference_points = reference_points
            
    def discrete_orientation(self, points):
        """Assign a discrete "closest orientation" for an input polyhedron of points.
        
        Args:
            points (np.array(float)): Nx3 numpy array of points describing the coordinates of the
                input polyhedron, centered around zero.
        
        For example, a tetrahedon has 12 pure rotation symmetry operations. A distorted
        tetrahedron with vertices approximately aligned along the unordered vectors
            [[ 1.0, -1.0,  1.0],
             [-1.0, -1.0, -1.0],
             [ 1.0,  1.0, -1.0],
             [-1.0,  1.0,  1.0]]
        therefore can be in one of 12 orientations. This method compares the input points to
        all permutations of self.reference_points that can be generated by proper rotations, and returns
        an index for orientation that minimises the rotational distance between the reordered
        reference points and the input points.
        
        The algorithm is:
        1. Perform continuous symmetry measure analysis for all permutations of reference points.
        2. Collect operations that have the minimum continous symmetry measure value.
        These give the set of all propert and improper rotations.
        3. Find all proper rotations using det(M_rot)>0.
        4. Calculate the rotational distance """
        points -= np.mean(points, axis=0, dtype=float)
        sm = [ symmetry_measure(points,p) for p in permutations(self.reference_points) ]
        min_sm =  min([s['symmetry_measure'] for s in sm])
        pure_rot_sm = [s for s in sm if math.isclose(s['symmetry_measure'],min_sm)]
        proper_rot_sm = [ s for s in pure_rot_sm if np.linalg.det(s['rotation_matrix']) > 0 ]
        proper_rot_matrices = np.array( [s['rotation_matrix'] for s in proper_rot_sm] )
        trace = np.trace(proper_rot_matrices, axis1=1, axis2=2 )
        rot_distance = np.arccos((trace-1.0)/2.0)
        index = np.argmin(rot_distance)
        return {'orientation_index': index,
                'rotational_distance': rot_distance[index], 
                'symmetry_measure': proper_rot_sm[index]['symmetry_measure'] }

    def polyhedron_orientation(self, polyhedron):
        points = polyhedron.abstract_geometry.points_wocs_csc()
        return self.discrete_orientation( points )
